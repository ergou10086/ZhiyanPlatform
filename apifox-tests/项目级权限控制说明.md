# 项目级权限控制系统说明

## 🎯 核心概念

你的系统现在实现了**项目级别的细粒度权限控制**，用户在不同项目中的角色和权限是**独立隔离**的。

### 场景示例

假设用户"张三"：
- 在 **"智研"** 项目中是 `OWNER`（拥有者）→ ✅ 可以删除项目
- 在 **"梦景"** 项目中是 `MEMBER`（成员）→ ❌ **不能**删除项目

---

## 📋 项目角色定义

### 1. OWNER（项目拥有者）

**拥有的权限**：
- ✅ `PROJECT_MANAGE` - 管理项目基本信息
- ✅ `PROJECT_DELETE` - **删除项目**（独享）
- ✅ `MEMBER_MANAGE` - 管理项目成员
- ✅ `KNOWLEDGE_MANAGE` - 管理项目知识库
- ✅ `TASK_MANAGE` - 管理项目任务
- ✅ `TASK_CREATE` - 创建项目任务

**可以执行的操作**：
- ✅ 更新项目信息
- ✅ 删除项目
- ✅ 归档项目
- ✅ 更新项目状态
- ✅ 添加/删除成员
- ✅ 管理任务
- ✅ 管理知识库

### 2. MEMBER（普通成员）

**拥有的权限**：
- ✅ `KNOWLEDGE_MANAGE` - 管理项目知识库
- ✅ `TASK_MANAGE` - 管理项目任务
- ✅ `TASK_CREATE` - 创建项目任务

**可以执行的操作**：
- ✅ 查看项目信息
- ✅ 更新项目基本信息（有PROJECT_MANAGE权限的话）
- ✅ 管理任务
- ✅ 管理知识库
- ❌ **不能**删除项目
- ❌ **不能**归档项目
- ❌ **不能**管理成员

---

## 🔐 权限控制实现

### 实现机制

#### 1. ProjectSecurityUtils 工具类

位置：`zhiyan-modules/zhiyan-project/src/main/java/hbnu/project/zhiyanproject/utils/ProjectSecurityUtils.java`

**主要方法**：

```java
// 检查是否为项目成员
boolean isMember(Long projectId)

// 检查是否为项目拥有者
boolean isOwner(Long projectId)

// 检查是否拥有指定权限
boolean hasPermission(Long projectId, ProjectPermission permission)

// 要求必须是项目成员（否则抛异常）
void requireMember(Long projectId)

// 要求必须是项目拥有者（否则抛异常）
void requireOwner(Long projectId)

// 要求必须有指定权限（否则抛异常）
void requirePermission(Long projectId, ProjectPermission permission)
```

#### 2. Controller层权限检查

**示例 - 删除项目**：

```java
@DeleteMapping("/{projectId}")
@PreAuthorize("isAuthenticated()")  // 只检查是否登录
public R<Void> deleteProject(@PathVariable Long projectId) {
    Long userId = SecurityUtils.getUserId();
    
    // 项目级权限检查：必须是项目拥有者才能删除
    projectSecurityUtils.requirePermission(projectId, ProjectPermission.PROJECT_DELETE);
    
    return projectService.deleteProject(projectId, userId);
}
```

**执行流程**：
1. 检查用户是否登录（Spring Security）
2. 检查用户在**该项目**中是否有 `PROJECT_DELETE` 权限
3. 如果没有权限，抛出 `SecurityException`
4. 如果有权限，执行删除操作

---

## 🧪 测试场景

### 场景1：创建项目

**任何登录用户都可以创建项目**

```http
POST http://localhost:8080/api/projects?name=智研项目
Authorization: Bearer {{accessToken}}
```

**结果**：
- ✅ 项目创建成功
- ✅ 创建者自动成为该项目的 `OWNER`

---

### 场景2：同一用户在不同项目中的权限

#### 前置条件：
- 用户张三（userId=1）
- 项目A（projectId=100）：张三是 `OWNER`
- 项目B（projectId=200）：张三是 `MEMBER`

#### 测试：删除项目A（成功）

```http
DELETE http://localhost:8080/api/projects/100
Authorization: Bearer {{accessToken}}
```

**预期结果**：
- ✅ 200 OK
- ✅ 项目A被删除
- 原因：张三在项目A中是OWNER，拥有PROJECT_DELETE权限

#### 测试：删除项目B（失败）

```http
DELETE http://localhost:8080/api/projects/200
Authorization: Bearer {{accessToken}}
```

**预期结果**：
- ❌ 403 Forbidden 或 500
- ❌ 错误信息："您在该项目中没有 删除项目 权限"
- 原因：张三在项目B中只是MEMBER，没有PROJECT_DELETE权限

---

### 场景3：更新项目

#### 测试：更新项目A（成功）

```http
PUT http://localhost:8080/api/projects/100?name=新名称
Authorization: Bearer {{accessToken}}
```

**预期结果**：
- ✅ 200 OK
- ✅ 项目信息更新成功
- 原因：张三在项目A中是OWNER，拥有PROJECT_MANAGE权限

#### 测试：更新项目B（取决于MEMBER是否有PROJECT_MANAGE权限）

根据当前的 `ProjectMemberRole` 定义，MEMBER **没有** PROJECT_MANAGE 权限，所以：

```http
PUT http://localhost:8080/api/projects/200?name=新名称
Authorization: Bearer {{accessToken}}
```

**预期结果**：
- ❌ 403 Forbidden
- ❌ 错误信息："您在该项目中没有 管理项目基本信息 权限"

---

### 场景4：归档项目

**只有项目拥有者可以归档**

#### 测试：归档项目A（成功）

```http
POST http://localhost:8080/api/projects/100/archive
Authorization: Bearer {{accessToken}}
```

**预期结果**：
- ✅ 200 OK
- ✅ 项目归档成功

#### 测试：归档项目B（失败）

```http
POST http://localhost:8080/api/projects/200/archive
Authorization: Bearer {{accessToken}}
```

**预期结果**：
- ❌ 403 Forbidden
- ❌ 错误信息："只有项目拥有者可以执行此操作"

---

## 📊 权限对照表

| 操作 | 接口 | OWNER | MEMBER | 说明 |
|------|------|-------|--------|------|
| 创建项目 | POST /api/projects | ✅ | ✅ | 任何登录用户 |
| 更新项目 | PUT /api/projects/{id} | ✅ | ❌ | 需要PROJECT_MANAGE |
| 删除项目 | DELETE /api/projects/{id} | ✅ | ❌ | 需要PROJECT_DELETE |
| 查看项目 | GET /api/projects/{id} | ✅ | ✅ | 登录即可 |
| 更新状态 | PATCH /api/projects/{id}/status | ✅ | ❌ | 需要PROJECT_MANAGE |
| 归档项目 | POST /api/projects/{id}/archive | ✅ | ❌ | 只有OWNER |
| 管理成员 | /api/project-members | ✅ | ❌ | 需要MEMBER_MANAGE |
| 管理任务 | /api/tasks | ✅ | ✅ | 需要TASK_MANAGE |
| 创建任务 | POST /api/tasks | ✅ | ✅ | 需要TASK_CREATE |
| 管理知识库 | /api/knowledge | ✅ | ✅ | 需要KNOWLEDGE_MANAGE |

---

## 🔄 如何给MEMBER添加更多权限

如果你想让MEMBER也能更新项目，修改 `ProjectMemberRole` 枚举：

```java
MEMBER("项目成员", "项目普通成员，基础参与权限", Arrays.asList(
        ProjectPermission.PROJECT_MANAGE,    // ← 添加这一行
        ProjectPermission.KNOWLEDGE_MANAGE,
        ProjectPermission.TASK_MANAGE,
        ProjectPermission.TASK_CREATE
))
```

---

## 🚨 错误处理

### 常见错误

#### 1. SecurityException - 没有权限

```json
{
  "error": "SecurityException",
  "message": "您在该项目中没有 删除项目 权限"
}
```

**原因**：用户在该项目中没有所需权限

**解决**：
- 检查用户在项目中的角色
- 确认该角色是否有对应权限
- 或者让项目拥有者添加权限

#### 2. SecurityException - 不是项目成员

```json
{
  "error": "SecurityException",
  "message": "您不是该项目的成员，无权访问"
}
```

**原因**：用户不是项目成员

**解决**：
- 加入项目
- 或者使用公开接口查看项目（如果是公开项目）

---

## 💡 最佳实践

### 1. 权限检查顺序

```java
// 1. 先检查是否登录（Spring Security）
@PreAuthorize("isAuthenticated()")

// 2. 再检查项目级权限（方法内部）
projectSecurityUtils.requirePermission(projectId, ProjectPermission.XXX);

// 3. 执行业务逻辑
```

### 2. 选择合适的检查方法

```java
// 场景1：只要是项目成员就可以
projectSecurityUtils.requireMember(projectId);

// 场景2：必须是项目拥有者
projectSecurityUtils.requireOwner(projectId);

// 场景3：需要特定权限
projectSecurityUtils.requirePermission(projectId, ProjectPermission.PROJECT_DELETE);
```

### 3. 友好的错误提示

```java
try {
    projectSecurityUtils.requirePermission(projectId, ProjectPermission.PROJECT_DELETE);
} catch (SecurityException e) {
    return R.fail("您没有删除该项目的权限，请联系项目拥有者");
}
```

---

## 🎯 总结

### ✅ 现在实现的效果

1. **项目隔离**：用户在不同项目中的权限完全独立
2. **细粒度控制**：每个操作都有明确的权限要求
3. **灵活扩展**：可以轻松添加新的角色和权限
4. **安全可靠**：双重检查（登录 + 项目权限）

### 🔐 权限层级

```
全局登录（Spring Security）
    ↓
项目成员身份
    ↓
项目角色（OWNER/MEMBER）
    ↓
具体权限（PROJECT_DELETE等）
```

### 📝 示例总结

**张三的权限**：
- 智研项目（OWNER）→ 可以做**任何事情**
- 梦景项目（MEMBER）→ 只能做**成员允许的事情**，**不能删除项目**

**这就是项目级权限控制！** 🎉

