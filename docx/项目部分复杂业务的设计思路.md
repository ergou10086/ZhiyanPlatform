### 知识库的markdown文档部分
使用 MongoDB 存储markdown文档

结合 Git 实现多人协同操作

不再将Markdown的全文直接存入传统数据库。数据库只负责存储元数据（Metadata），而内容本身交给Git仓库来管理。

**数据库 (MySQL/PostgreSQL/MongoDB 均可)**

- `documents` 表/集合：
  - `id` (主键)
  - `title` (标题)
  - `git_repo_path` (Git仓库在服务器上的路径或唯一标识)
  - `creator_id`
  - `access_control_list` (权限控制列表)
  - ... 其他元数据

**内容存储 (文件系统 + Git)**

- 在你的微服务能访问到的服务器文件系统上，为每一篇文档创建一个独立的裸Git仓库 (`git init --bare`)。
- 所有对文档的修改，都转化为Git的 `commit` 操作。

协作实现：

- **读取文档**：服务通过文档ID找到Git仓库路径，然后 `git show HEAD:document.md` 来获取最新内容。
- **修改文档**：
  1. 用户提交修改内容。
  2. 微服务将新内容写入临时文件。
  3. 执行 `git add document.md` 和 `git commit -m "commit message" --author="username <user@email.com>"`.
  4. Git会自动处理版本、差异（diff）和历史记录。
- **查看历史**：执行 `git log`。
- **版本回滚**：执行 `git revert` 或 `git reset`。
- **多人协作**：Git天生就是为多人协作设计的。虽然Web应用中不直接用 `pull/push`，但可以模拟分支和合并（merge）的逻辑来解决冲突。
- **实时协作**：要实现实时协作，可以在此基础上引入 **CRDT (Conflict-free Replicated Data Types)** 或 **OT (Operational Transformation)** 算法。用户的每次按键操作（增、删字符）都作为一个“操作指令”发送到后端，后端将这些指令存起来并广播给其他协作者。Git仓库则在用户“保存”或系统自动快照时，将这些操作指令应用后的最终结果进行一次 `commit`，作为历史检查点。

### wiki文档存储管理的实现

设计思路

```text   
文件层（MinIO）
    ↓ 文件URL引用
元数据层（MySQL）← 关联 → 文档内容层（MongoDB）
    ↓ 索引同步
搜索层（Elasticsearch）
```

但是由于 ES 的巨大性，暂且不引入

```text
MySQL (元数据 + 关系)
    ↓ 关联ID
MongoDB (文档内容 + 版本历史 + 全文索引)
    ↓ 附件引用
MinIO (二进制文件)   
```

**核心设计原则：**

- MySQL：存储所有结构化、关系型数据（成果元数据、用户、项目关联等）
- MongoDB：存储Wiki的Markdown内容、版本历史等半结构化数据
- MinIO：存储所有二进制文件（PDF、数据集、附件等）
- Elasticsearch：同步MySQL和MongoDB的内容用于全文检索

**数据分工**：

```
存储            负责内容                  理由
MySQL    页面元数据、项目关联、权限  强关系型、事务保证
MongoDBMarkdown 内容、版本历史文档  灵活、写入性能好
Elasticsearch 全文索引             专业搜索引擎
MinIO       图片、附件                 对象存储
```



### 成果自定义模板的实现

首先，成果对应一个成果详情，成果详情中可以使用 JSON 对象的结构描述其详情





